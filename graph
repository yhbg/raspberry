//방향성 없는 그래프
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <math.h>

#define MAX_VERTEX 500

typedef struct graphType {
   int n;
   int adjMatrix[MAX_VERTEX][MAX_VERTEX];
   int degree[MAX_VERTEX];
} graphType;


void createGraph(graphType* g) {
   int i, j;
   g->n = 0;
   for (i = 0; i<MAX_VERTEX; i++)   // degree 배열 모두 0으로 초기화
      g->degree[i] = 0;
   for (i = 0; i < MAX_VERTEX; i++) {   // 인접행렬 모두 0으로 초기화
      for (j = 0; j < MAX_VERTEX; j++)
         g->adjMatrix[i][j] = 0;
   }
}

void insertVertex(graphType* g, int v) {
   if (((g->n) + 1) > MAX_VERTEX) {
      printf("\n 정점갯수 초과했습니다.");
      return;
   }
   g->n++;
}

void insertEdge(graphType* g, int u, int v) {
   if (u >= g->n || v >= g->n) {
      printf("\n 그래프에 없는 정점입니다.\n");
      return;
   }
   g->adjMatrix[u][v] = 1;
   g->adjMatrix[v][u] = 1;
}

void print_adjMatrix(graphType* g) {
   printf("Represent adjacency Matrix!");
   int i, j;
   for (i = 0; i < (g->n); i++) {
      printf("\n\t");
      for (j = 0; j < (g->n); j++)
         printf("%2d", g->adjMatrix[i][j]);
   }
}

void print_color(int* arr, int len) {
   char Board[10];
   Board[0] = '■' >> 8;
   Board[1] = '■';
   Board[2] = '□' >> 8;
   Board[3] = '□';
   printf("\n");

   for (int i = 0; i < len; i++) {
      if (arr[i] == 1)
         printf("%c%c", Board[2], Board[3]);
      else
         printf("%c%c", Board[0], Board[1]);

   }
}


int main() 
{
   int user_size, percent, gozip, ddorai;
   int count_node = 0, threshold = 0, black_node = 0, white_node = 0, priority_node = 0;
   int num_ddorai, num_gozip;
   int index_ddorai[MAX_VERTEX] = { -1 }, index_gozip[MAX_VERTEX] = { -1 };
   int i, j;
   int color[MAX_VERTEX];
   int edge_L, edge_R, number_edge, index_vertex = 0;
   srand(time(NULL));


   printf("*************************************\n");
   printf(" Enter the number of vertices: ");
   scanf_s("%d", &user_size);
   printf(" what percent do you want to replace ? ");
   scanf_s("%d", &percent);
   printf(" Enter the percent of ddorai? ");
   scanf_s("%d", &ddorai);
   printf(" Enter the percent of gozip? ");
   scanf_s("%d", &gozip);
   printf("*************************************\n");


   /*그래프 기반 생성*/
   graphType* g1;
   g1 = (graphType*)malloc(sizeof(graphType));
   createGraph(g1);
   int vertex_store[MAX_VERTEX];
   for (int i = 0; i < MAX_VERTEX; i++)
      vertex_store[i] = 0;


   /*바라바시 알버트 방법으로 그래프를 만들어 나감*/
   int new_edge = -1, optIndex = 0, indegree = 0, pick;
   int array[80000] = { -1 }, arr_index = 0, c = 3;

   insertVertex(g1, 0);   // 0번 노드 삽입됨
   for (i = 1; i < user_size; i++) {
      insertVertex(g1, i);   // 여기서 i번 노드가 삽입
      edge_L = i;    // i가 edge_L이 됨
      if (edge_L == 1) {
         insertEdge(g1, edge_L, 0);  //노드 0, 1 로 엣지 한개 만들었음 
      }
      else {   // i가 2일 때부터  
         do {
            number_edge = (rand() % 2) + 2;   // 2~3중 랜덤 생성 <= 연결 할 엣지의 수
         } while (g1->n < number_edge);
         for (int z = 0; z < number_edge; z++) {    //number_edge만큼 연결함
            int y, j;
            for (y = 0; y < (g1->n)-1; y++) {
               for (j = 0; j < (g1->n)-1; j++) {
                  if (g1->adjMatrix[y][j] == 1)
                     indegree++;      
               }
               g1->degree[y] = indegree;     // 한 노드에 있는 degree 수를 넣음
               indegree += c;   // degree에 상수 c를 더함
               while (indegree > 0) {
                  array[arr_index++] = y;   // 노드번호를 array에 indegree+c 갯수만큼 넣음
                  indegree--;
               }
               indegree = 0;
            }

         pick = rand() % arr_index;  // 배열 중 하나를 선택함 
         edge_R = array[pick];   //edge_R로 지정
         insertEdge(g1, edge_L, edge_R);   // edge를 연결함
         array[50000] = { -1 };   //array배열 초기화
         arr_index = 0;   // 인덱스 초기화
            
         }
      }
   }


   /* 각 노드에 color 정해줌 */
   for (int i = 0; i < user_size; i++)
      color[i] = rand() % 2;
   /* 고집불통과 또라이의 갯수를 구하고 각각의 인덱스도 구함 */
   num_ddorai = ceil((double)user_size * 1 / 100 * (double)ddorai);
   num_gozip = ceil((double)user_size * 1 / 100 * (double)gozip);

   printf("\n");
   printf(" Number of ddorai: %d\n", num_ddorai);
   printf(" Nuber of gozip: %d\n", num_gozip);

   for (int i = 0; i < (int)num_ddorai; i++)
      index_ddorai[i] = rand() % user_size;

   for (int i = 0; i < (int)num_gozip; i++) {
      int replay = -1, replay1 = -1, replay2 = -1, tmp;
      while (replay < 0) {
         tmp = rand() % user_size;

         for (int j = 0; j < (int)num_ddorai; j++) {
            if (tmp == index_ddorai[j])
               replay1 = -3;
         }
         for (int j = 0; j < i; j++) {
            if (tmp == index_gozip[j])
               replay2 = -4;
         }
         if (replay1 != -3 && replay2 != -4)
            replay = 1;
      }
      index_gozip[i] = tmp;
   }

   printf("*************************************\n");
   printf(" Prints ddorai \n");
   for (int i = 0; i < num_ddorai; i++)
      printf(" %d ", index_ddorai[i]+1);
   printf("\n");
   printf(" Prints gozip  \n");
   for (int i = 0; i < num_gozip; i++)
      printf(" %d ", index_gozip[i]+1);
   printf("\n");
   printf("*************************************\n");


   int tmp[MAX_VERTEX];
   for (int h = 0; h<MAX_VERTEX; h++)
      tmp[h] = 1;

   /*내 노드(각 행)의 색과 바꿀 %에 따라 */

   //print_adjMatrix(g1);
   printf("\n");

   while (1) {
      print_color(color, user_size);
      //printf("\n\n Press Enter to go to the next step! \n");
      getchar();
      printf("\n");

      for (i = 0; i < user_size; i++) {
         for (j = 0; j < user_size; j++) {
            if (g1->adjMatrix[i][j] == 1) {    //연결 되어 있음
               count_node++;
               if (color[j] == 1)
                  black_node++;
            }
         }
         threshold = ceil((double)(count_node) * 1 / 100 * (double)percent);
         //printf("threshold는 %d 이다.\n", (int)threshold);
         int discriminate[MAX_VERTEX];
         for (int h = 0; h<MAX_VERTEX; h++)
            discriminate[h] = 1;
         white_node = count_node - black_node;
         //printf("\n %d행의 연결노드갯수: %d개, 지 색깔: %d, 스레시홀드: %d개, 블랙노드: %d개, 화이트노드: %d개\n", i, count_node, color[i], threshold, black_node, white_node);

         //printf("\n");
         for (int k = 0; k < num_ddorai; k++) {
            if (i == index_ddorai[k]) {   // 또라이 노드일 경우
               discriminate[i] = -1;
               if (color[i] == 1) {   //검은색일 때
                  if (white_node != 0 && white_node >= (int)threshold) {
                     //printf("\t%d번 노드:****내 색은 검은색, threshold를 넘어갔으므로 바뀌지 않음\n", i+1);
                  }
                  else {
                     //printf("\t%d번 노드:****내 색은 검은색, threshold를 못넘어가거나, 흰색노드가 없어서 b->w로 바뀜\n", i + 1);
                     color[i] = 0;
                  }
               }
               else {    //흰색일 때
                  if (black_node != 0 && black_node >= (int)threshold) {
                     //printf("\t%d번 노드:****내 색은 흰색, threshold를 넘어갔으므로 바뀌지 않음\n", i + 1);
                  }
                  else {
                     //printf("\t%d번 노드:****내 색은 흰색, threshold를 못넘어가거나, 검정노드가 없어서 w->b으로 바뀜\n", i + 1);
                     color[i] = 1;
                  }
               }
            }
         }
         if (discriminate[i] > 0) {
            for (int k = 0; k < num_gozip; k++) {
               if (i == index_gozip[k]) {       // 고집 노드일 경우
                  //printf("\t%d번 노드:!!!!나의 색과 남의 색이 어떻든간 나는 바꾸지 않는 고집불통\n", i + 1);
                  discriminate[i] = -1;
               }
            }
         }
         if (discriminate[i] > 0) {
            if (color[i] == 1) {
               if (white_node != 0 && white_node >= (int)threshold) {
                  //printf("\t%d번 노드:내 색은 검은색, threshold를 넘어갔으므로 b->w로 바뀜\n", i + 1);
                  color[i] = 0;
               }
               else {
                  //printf("\t%d번 노드: 내 색은 검은색, threshold를 못넘어가거나, 흰색노드가 없어서 바뀌지 않음\n", i + 1);
               }
            }
            else {
               if (black_node != 0 && black_node >= (int)threshold) {
                  //printf("\t%d번 노드:내 색은 흰색, threshold를 넘어갔으므로 w->b로 바뀜\n", i + 1);
                  color[i] = 1;
               }
               else {
                  //printf("\t%d번 노드: 내 색은 흰색, threshold를 못넘어가거나, 검정노드가 없어서 바뀌지 않음\n", i + 1);
               }
            }
         }
         count_node = 0, black_node = 0, white_node = 0;
         tmp[i] = discriminate[i];
      }
   }
   return 0;
}
