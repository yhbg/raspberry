//방향성 없는 그래프
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <math.h>

#define MAX_VERTEX 500

typedef struct graphType {
   int n;
   int adjMatrix[MAX_VERTEX][MAX_VERTEX];
   int degree[MAX_VERTEX];
} graphType;


void createGraph(graphType* g) {
   int i, j;
   g->n = 0;
   for (i = 0; i<MAX_VERTEX; i++)   // degree 배열 모두 0으로 초기화
      g->degree[i] = 0;
   for (i = 0; i < MAX_VERTEX; i++) {   // 인접행렬 모두 0으로 초기화
      for (j = 0; j < MAX_VERTEX; j++)
         g->adjMatrix[i][j] = 0;
   }
}

void insertVertex(graphType* g, int v) {
   if (((g->n) + 1) > MAX_VERTEX) {
      printf("\n 정점갯수 초과했습니다.");
      return;
   }
   g->n++;
}

void insertEdge(graphType* g, int u, int v) {
   if (u >= g->n || v >= g->n) {
      printf("\n 그래프에 없는 정점입니다.\n");
      return;
   }
   g->adjMatrix[u][v] = 1;
   g->adjMatrix[v][u] = 1;
}

void print_adjMatrix(graphType* g) {
   printf("Represent adjacency Matrix!");
   int i, j;
   for (i = 0; i < (g->n); i++) {
      printf("\n\t");
      for (j = 0; j < (g->n); j++)
         printf("%2d", g->adjMatrix[i][j]);
   }
}

void print_color(int* arr, int len) {
   char Board[10];
   Board[0] = '■' >> 8;
   Board[1] = '■';
   Board[2] = '□' >> 8;
   Board[3] = '□';
   printf("\n");

   for (int i = 0; i < len; i++) {
      if (arr[i] == 1)
         printf("%c%c", Board[2], Board[3]);
      else
         printf("%c%c", Board[0], Board[1]);

   }
}


int main() 
{
   int user_size, percent, gozip, ddorai;
   int count_node = 0, threshold = 0, black_node = 0, white_node = 0, priority_node = 0;
   int num_ddorai, num_gozip;
   int index_ddorai[MAX_VERTEX] = { -1 }, index_gozip[MAX_VERTEX] = { -1 };
   int i, j;
   int color[MAX_VERTEX];
   int edge_L, edge_R, number_edge, index_vertex = 0;
   srand(time(NULL));


   printf("*************************************\n");
   printf(" Enter the number of vertices: ");
   scanf_s("%d", &user_size);
   printf(" what percent do you want to replace ? ");
   scanf_s("%d", &percent);
   printf(" Enter the percent of ddorai? ");
   scanf_s("%d", &ddorai);
   printf(" Enter the percent of gozip? ");
   scanf_s("%d", &gozip);
   printf("*************************************\n");


   /*그래프 기반 생성*/
   graphType* g1;
   g1 = (graphType*)malloc(sizeof(graphType));
   createGraph(g1);
   int vertex_store[MAX_VERTEX];
   for (int i = 0; i < MAX_VERTEX; i++)
      vertex_store[i] = 0;


   /*바라바시 알버트 방법으로 그래프를 만들어 나감*/
   int new_edge = -1, optIndex = 0, indegree = 0, pick;
   int array[80000] = { -1 }, arr_index = 0, c = 3;

   insertVertex(g1, 0);   // 0번 노드 삽입됨
   for (i = 1; i < user_size; i++) {
      insertVertex(g1, i);   // 여기서 i번 노드가 삽입
      edge_L = i;    // i가 edge_L이 됨
      if (edge_L == 1) {
         insertEdge(g1, edge_L, 0);  //노드 0, 1 로 엣지 한개 만들었음 
      }
      else {   // i가 2일 때부터  
         do {
            number_edge = (rand() % 2) + 2;   // 2~3중 랜덤 생성 <= 연결 할 엣지의 수
         } while (g1->n < number_edge);
         for (int z = 0; z < number_edge; z++) {    //number_edge만큼 연결함
            int y, j;
            for (y = 0; y < (g1->n)-1; y++) {
               for (j = 0; j < (g1->n)-1; j++) {
                  if (g1->adjMatrix[y][j] == 1)
                     indegree++;      
               }
               g1->degree[y] = indegree;     // 한 노드에 있는 degree 수를 넣음
               indegree += c;   // degree에 상수 c를 더함
               while (indegree > 0) {
                  array[arr_index++] = y;   // 노드번호를 array에 indegree+c 갯수만큼 넣음
                  indegree--;
               }
               indegree = 0;
            }

         pick = rand() % arr_index;  // 배열 중 하나를 선택함 
         edge_R = array[pick];   //edge_R로 지정
         insertEdge(g1, edge_L, edge_R);   // edge를 연결함
         array[50000] = { -1 };   //array배열 초기화
         arr_index = 0;   // 인덱스 초기화
            
         }
      }
   }


   /* 각 노드에 color 정해줌 */
   for (int i = 0; i < user_size; i++)
      color[i] = rand() % 2;
   /* 고집불통과 또라이의 갯수를 구하고 각각의 인덱스도 구함 */
   num_ddorai = ceil((double)user_size * 1 / 100 * (double)ddorai);
   num_gozip = ceil((double)user_size * 1 / 100 * (double)gozip);

   printf("\n");
   printf(" Number of ddorai: %d\n", num_ddorai);
   printf(" Nuber of gozip: %d\n", num_gozip);

   for (int i = 0; i < (int)num_ddorai; i++)
      index_ddorai[i] = rand() % user_size;

   for (int i = 0; i < (int)num_gozip; i++) {
      int replay = -1, replay1 = -1, replay2 = -1, tmp;
      while (replay < 0) {
         tmp = rand() % user_size;

         for (int j = 0; j < (int)num_ddorai; j++) {
            if (tmp == index_ddorai[j])
               replay1 = -3;
         }
         for (int j = 0; j < i; j++) {
            if (tmp == index_gozip[j])
               replay2 = -4;
         }
         if (replay1 != -3 && replay2 != -4)
            replay = 1;
      }
      index_gozip[i] = tmp;
   }

   printf("*************************************\n");
   printf(" Prints ddorai \n");
   for (int i = 0; i < num_ddorai; i++)
      printf(" %d ", index_ddorai[i]+1);
   printf("\n");
   printf(" Prints gozip  \n");
   for (int i = 0; i < num_gozip; i++)
      printf(" %d ", index_gozip[i]+1);
   printf("\n");
   printf("*************************************\n");


   int tmp[MAX_VERTEX];
   for (int h = 0; h<MAX_VERTEX; h++)
      tmp[h] = 1;

   /*내 노드(각 행)의 색과 바꿀 %에 따라 */

   //print_adjMatrix(g1);
   printf("\n");

   while (1) {
      print_color(color, user_size);
      //printf("\n\n Press Enter to go to the next step! \n");
      getchar();
      printf("\n");

      for (i = 0; i < user_size; i++) {
         for (j = 0; j < user_size; j++) {
            if (g1->adjMatrix[i][j] == 1) {    //연결 되어 있음
               count_node++;
               if (color[j] == 1)
                  black_node++;
            }
         }
         threshold = ceil((double)(count_node) * 1 / 100 * (double)percent);
         //printf("threshold는 %d 이다.\n", (int)threshold);
         int discriminate[MAX_VERTEX];
         for (int h = 0; h<MAX_VERTEX; h++)
            discriminate[h] = 1;
         white_node = count_node - black_node;
         //printf("\n %d행의 연결노드갯수: %d개, 지 색깔: %d, 스레시홀드: %d개, 블랙노드: %d개, 화이트노드: %d개\n", i, count_node, color[i], threshold, black_node, white_node);

         //printf("\n");
         for (int k = 0; k < num_ddorai; k++) {
            if (i == index_ddorai[k]) {   // 또라이 노드일 경우
               discriminate[i] = -1;
               if (color[i] == 1) {   //검은색일 때
                  if (white_node != 0 && white_node >= (int)threshold) {
                     //printf("\t%d번 노드:****내 색은 검은색, threshold를 넘어갔으므로 바뀌지 않음\n", i+1);
                  }
                  else {
                     //printf("\t%d번 노드:****내 색은 검은색, threshold를 못넘어가거나, 흰색노드가 없어서 b->w로 바뀜\n", i + 1);
                     color[i] = 0;
                  }
               }
               else {    //흰색일 때
                  if (black_node != 0 && black_node >= (int)threshold) {
                     //printf("\t%d번 노드:****내 색은 흰색, threshold를 넘어갔으므로 바뀌지 않음\n", i + 1);
                  }
                  else {
                     //printf("\t%d번 노드:****내 색은 흰색, threshold를 못넘어가거나, 검정노드가 없어서 w->b으로 바뀜\n", i + 1);
                     color[i] = 1;
                  }
               }
            }
         }
         if (discriminate[i] > 0) {
            for (int k = 0; k < num_gozip; k++) {
               if (i == index_gozip[k]) {       // 고집 노드일 경우
                  //printf("\t%d번 노드:!!!!나의 색과 남의 색이 어떻든간 나는 바꾸지 않는 고집불통\n", i + 1);
                  discriminate[i] = -1;

}
            }
         }
         if (discriminate[i] > 0) {
            if (color[i] == 1) {
               if (white_node != 0 && white_node >= (int)threshold) {
                  //printf("\t%d번 노드:내 색은 검은색, threshold를 넘어갔으므로 b->w로 바뀜\n", i + 1);
                  color[i] = 0;
               }
               else {
                  //printf("\t%d번 노드: 내 색은 검은색, threshold를 못넘어가거나, 흰색노드가 없어서 바뀌지 않음\n", i + 1);
               }
            }
            else {
               if (black_node != 0 && black_node >= (int)threshold) {
                  //printf("\t%d번 노드:내 색은 흰색, threshold를 넘어갔으므로 w->b로 바뀜\n", i + 1);
                  color[i] = 1;
               }
               else {
                  //printf("\t%d번 노드: 내 색은 흰색, threshold를 못넘어가거나, 검정노드가 없어서 바뀌지 않음\n", i + 1);
               }
            }
         }
         count_node = 0, black_node = 0, white_node = 0;
         tmp[i] = discriminate[i];
      }
   }
   return 0;
}

//////////////////////////////////////////////비트코인 start/////////////////////////////////////////////////////////////////
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<process.h>
#include<time.h>
#include<string.h>

using namespace std;

class User
{
public :
   char UserID[15], UserPass[15];
   int ComNum, Howbuy[4], BuyPri,Nowass; 
   // ComNum : 사는 거래소 번호 
   // Howbuy[4] : 어떤 거래소가 얼마나 코인을 살건지 
   //BuyPri : 살때 가격 
   //Nowass : 현재 재산 
   int Regbusi[6][6];  // 비지니스 등록 
   void Regtrans(int playernumber,int BuyComNum,int amtbuystock,char BoS);  // 거래 등록 함수 
   void Printtrans(int playernumber); // 거래 목록 프린트 
   void NowMyStock(int playernumber); //메뉴1 : 현재 플레이어들의 주식 보기 함수 
};


class Company
{
public :
   int ComNum, ComStock, StPri, beforeStPri; 
   // ComNum : 거래소 번호
   // ComStock : 회사 거래량 
   // StPri : 코인 가격 
   //beforeStPri : 어제 코인 가격 
   char ComName[15];
   int StockPricef(int StPri);  //코인 가격 변동 함수 
}; 

void initialize(void);  //거래소, 사용자 초기화 
int PrintMenu(void);  // 회원가입 페이지 
int PrintMenu2(int date); // 멤버 점검 후 출력, 로그인 페이지 
void StoreUser(int count);  // 유저 아이디랑 비번 저장 
int InspUser(int count);  // 유저 점검 
void StockTrans(int playernumber); // 코인거래 함수 
User player[4];
Company Com[4];    //유저와 거래소 선언 

int date =1,transcnt=0;   //date = 턴, transcnt = 거래 카운트 
int workcnt = date;  // workcnt : 거래 후에도 날짜가 같다면 가격 변동 ㄴ 




int main()
{
   int count,inspect,Select;

   count = PrintMenu();
   initialize();

   srand(time(NULL));   // 거래 가격 변경 

   StoreUser(count);  
   inspect = InspUser(count);   //inspect = 유저가 로그인했는지 , the result is User number +1, or the result is 0 
   
   while(inspect)  // 로그인 성공 
   {
      int PN;  //PN = 플레이어 넘버 
      PN = inspect - 1;

      if(Select==4)
      {
         date++;
         workcnt = date;
      }

      Select = PrintMenu2(date);

      switch (Select)  
      {
         case 1 :  //메뉴 1 : 현재 유저의 코인 정보 출력 
            player[PN].NowMyStock(PN);
            break;
         case 2 :  // 메뉴 2 : buy or sell 가능 
            StockTrans(PN);
            workcnt++;
            break;
         case 3 : // 메뉴 3 : 최근 거래 리스트 6개 조회 가능 
            player[PN].Printtrans(PN);            
            break;
         case 4 : // 메뉴 4 : 턴을 1 증가 
            date++;
            workcnt = date;
            Select = PrintMenu2(date);
            break;
         case 5 : // 메뉴 5 : 사용자 변경 
            inspect = InspUser(count);
            break;
         case 6 : // 메뉴 6 : 프로그램 종료 
            inspect = 0;
            break;
      }
   }
   if(!inspect && Select !=6)
      cout << "\n\n\nID 또는 PW가 일치하지 않음. 종료\n";
   return 0;
}

void initialize(void)
{
   for(int i=0;i<4;i++)
   {
      player[i].Howbuy[i] =0;
      player[i].Nowass = 100000;
      Com[i].ComStock = 100;
      Com[i].StPri = 5000;
      Com[i].ComNum  =i+1;
   }  
   strcpy(Com[0].ComName,"거래소1");
//   strcpy(Com[1].ComName,"거래소2");
//   strcpy(Com[2].ComName,"거래소3");
//   strcpy(Com[3].ComName,"거래소4");
}  // 초기화단계

 
int PrintMenu(void)
{ 
   int k;
   char str[30];
   cout << "등록할 회원의 수를 입력하세요(인원제한4명)\t[ ]\b\b";
   gets(str);
   k=atoi(str); // cin 대신 쓴 
   return k; 
}

int PrintMenu2(int date)
{
   int input;
    char str[30];
   system("cls");
   cout << "\n\t지금은 거래 시작 " << date << " 일째 입니다.\n\n";
   cout << "\t1. 현재보유코인보기\n";
   cout << "\t2. 코인구매/판매\n";
   cout << "\t3. 거래내역보기\n";
   cout << "\t4. 턴종료(날짜이동)\n";
   cout << "\t5. 유저이동\n";
   cout << "\t6. 프로그램 종료\n\n";
   cout << "\t메뉴를 선택하세요\t[ ]\b\b";
    gets(str);  //cin 대 신 
    input=atoi(str);
   return input;
}

void StoreUser(int count)
{
   int i=0;
   while(i<count)
   {
      system("cls");
      cout << "\t\t회원가입 페이지 입니다.\n";
      cout << " \n 가입할 ID를 입력하세요(영문,숫자조합 8자이내)   ";
      gets(player[i].UserID);
      cout << " 비밀번호를 입력하세요   ";
      gets(player[i].UserPass);
      i++;
   }
}

int InspUser(int count)
{
   int flag,flagP,result,i=0;
   char inspectID[15], inspectPass[15];   
   system("cls");
   cout << " ID를 입력하세요 (단, 대소문자구별 없음)   ";
   gets(inspectID);
   cout << " 비밀번호를 입력하세요   ";
   gets(inspectPass);
   
   while(i<count)  // 모든 유저 정보 점검 
   {
      flag = stricmp(inspectID,player[i].UserID);
      flagP = stricmp(inspectPass,player[i].UserPass);
     
      if(flag==0 && flagP==0)  // 로그인 성공 
      {
         result = 1+i;
         break;
      }else //로그인실패 
         result = 0;
      i++;
   }
   return result;
}


int Company :: StockPricef(int StPri)  //어느것이든 4이상만 되면 가격오 름 
{
   int c;
   for(int i =0;i<4;i++) {
   	
//Com[i].StPri - Com[i].beforeStPri
  
	// player[playernumber].Howbuy[i];
   int playernumber;
   
   //hwakrul = rand()%5;
   if((player[playernumber].Howbuy[0])>17) // 2/5 : stock price increase
      c = StPri + (rand()%(StPri/10));
   else if((player[playernumber].Howbuy[0])>13&&(player[playernumber].Howbuy[0])<=17)  // 2/5 : stock price decrease
      c = StPri + (rand()%(StPri/10));
	else if((player[playernumber].Howbuy[0])>9&&(player[playernumber].Howbuy[0])<=13)  // 2/5 : stock price decrease
      c = StPri + (rand()%(StPri/10));   
   else if((player[playernumber].Howbuy[0])>5&&(player[playernumber].Howbuy[0])<=9)  // 2/5 : stock price decrease
      c = StPri;
   else  // 1/5 : stock price don't be changed
      c = StPri-(rand()%(StPri/10));
   return c;
	}
}


void StockTrans(int playernumber)
{
   if(player[playernumber].Nowass >0)
   {
      int BorS,BuyComNum,amtbuystock;
      system("cls");
      cout << "\n\t***************코인관리시스템*****************\n\n";
      cout << "\t\t\t전체시장시세\n\n";
      cout << "번호 거래소명  금일시세  전일시세  등락폭  코인수  거래자금";
      printf("    %s님보유현황\n\n",player[playernumber].UserID);

      for(int i=0;i<1;i++)
      {
         if(workcnt == date)
         {
            Com[i].beforeStPri = Com[i].StPri;
            Com[i].StPri= Com[i].StockPricef(Com[i].StPri); // 같은 턴, 코인 가격 변동 하지 마셈 
         }
         printf("%3d  %s\t%4d%10d",Com[i].ComNum,Com[i].ComName,Com[i].StPri,Com[i].beforeStPri);
      
         if(Com[i].beforeStPri-Com[i].StPri < 0)  // 가격상승했을경우 
            printf("\t  ▲ ");
         else if(Com[i].beforeStPri-Com[i].StPri == 0)  // 가격변동 없을경우 
            printf("\t  ━ ");
         else  // 가격 하락햇을경우 
            printf("\t  ▼ ");
         
         printf("%3d%7d    %d",abs(Com[i].beforeStPri -Com[i].StPri), Com[i].ComStock, Com[i].ComStock*Com[i].StPri);
         printf("%12d\n\n",player[playernumber].Howbuy[i]);
      }

      printf("\t%s님 코인구매/판매\n\n",player[playernumber].UserID);

      printf("\t현재 보유코인은 %d원 입니다.\n\n",player[playernumber].Nowass);
   
      cout << "\t구매하시려면 B를, 매각하시려면 S를 입력하세요\t[ ]\b\b";
      BorS = getchar();
   
      if(BorS == 'B'|| BorS == 'b')
      {
         cout << "\t-> 사실 거래소의 번호를 눌러주세요.";
         scanf("%d",&BuyComNum);
         cout << "\t-> 얼마만큼의 코인을 보유하시겠습니까?";
         scanf("%d",&amtbuystock);
         cout << "\t";

         if(player[playernumber].Nowass <= 0 || player[playernumber].Nowass < (amtbuystock*Com[BuyComNum-1].StPri))
            cout << "\t그만큼 구매할 수는 없습니다.\n\n\t";
         else
         {
            Com[BuyComNum-1].ComStock = Com[BuyComNum-1].ComStock + amtbuystock;  // 코인 양 +
            player[playernumber].ComNum = BuyComNum - 1;  // 거래소 이름 저장
            player[playernumber].Howbuy[BuyComNum-1] += amtbuystock;  // 코인 양 저장 
            player[playernumber].Nowass -= Com[BuyComNum-1].StPri*amtbuystock;  // 현재 자산 저장 
            transcnt++;  //유저가 코인사는데 성공햇을 시 변수에 +1 
            player[playernumber].Regtrans(playernumber,BuyComNum,amtbuystock,BorS);  // regist transection
         }

      }else if(BorS == 'S' || BorS == 's')
      {
         cout << "\t-> 팔 거래소의 번호를 눌러주세요.";
         scanf("%d",&BuyComNum);
         cout << "\t-> 얼마만큼의 코인을 팔겠습니까?";
         scanf("%d",&amtbuystock);      

         if(player[playernumber].Howbuy[BuyComNum-1] < amtbuystock)
            cout << "\t그만큼 팔 수는 없습니다.\n\n\t";
         else
         {
            Com[BuyComNum-1].ComStock = Com[BuyComNum-1].ComStock - amtbuystock;   // 코인 양 - 
            player[playernumber].ComNum = BuyComNum - 1; 
            player[playernumber].Howbuy[BuyComNum-1] -= amtbuystock;  
            player[playernumber].Nowass += Com[BuyComNum-1].StPri*amtbuystock;  
            transcnt++; // 유저가 코인 파는데 성공했을 시 이 변수에 +1 
            player[playernumber].Regtrans(playernumber,BuyComNum,amtbuystock,BorS);  
         }   
      }else
        cout << "잘못입력하셨습니다. 메뉴화면으로 이동합니다.\n\n\t";
    	system("pause");
   }else{
      	cout << "\n\t돈을 가지고 있지 않습니다. 메뉴화면으로 이동합니다.\n\n\t";
      	system("pause");
   }
}


void User :: Regtrans(int playernumber,int BuyComNum,int amtbuystock,char BoS)
{   
   if(transcnt<=6)
   {
      player[playernumber].Regbusi[5-(transcnt-1)][0]=date;// 거래 턴 
      player[playernumber].Regbusi[5-(transcnt-1)][1]=BuyComNum;// 거래소 번호 
      player[playernumber].Regbusi[5-(transcnt-1)][2]=Com[BuyComNum-1].StPri;// 코인 가격 
      player[playernumber].Regbusi[5-(transcnt-1)][3]=amtbuystock;// 코인 양 
      player[playernumber].Regbusi[5-(transcnt-1)][4]=Com[BuyComNum-1].StPri*amtbuystock;//코인가격 * 양 
      player[playernumber].Regbusi[5-(transcnt-1)][5]=BoS;// Buy 또는 sell 
   }else{
      for(int a=4;a>=0;a--)  //array[0]~[4]를 array[1]~[5]에 할당 
      {
         for(int b=0;b<6;b++)
    	 player[playernumber].Regbusi[a][b] = player[playernumber].Regbusi[a+1][b]; 
      }
      
      player[playernumber].Regbusi[0][0]=date;
      player[playernumber].Regbusi[0][1]=BuyComNum;
      player[playernumber].Regbusi[0][2]=Com[BuyComNum-1].StPri;
      player[playernumber].Regbusi[0][3]=amtbuystock;
      player[playernumber].Regbusi[0][4]=Com[BuyComNum-1].StPri*amtbuystock;
      player[playernumber].Regbusi[0][5]=BoS;
      // the most recent value is assigned in array[0] 
   }
}


void User :: Printtrans(int playernumber)  //거래 레지스터 
{
   system("cls");
   cout << "\t**************코인관리시스템입니다********************\n\n";
   printf("\t%s님 거래내역보기\n\n\n",player[playernumber].UserID);
   cout << " 거래턴  거래소명 당시코인금액 당시거래주 거래금액 구매/판매여부\n\n";

   if(transcnt)
   {
      if(transcnt <=6) // 거래 정보를 담고 있는  열만 출력 
      {
         for(int m=(5-(transcnt-1));m<=5;m++)
         {
            for(int n=0;n<6;n++)
            {
               if(n==1)
                  printf("%s  ",Com[player[playernumber].Regbusi[m][1]-1].ComName);
               else if(n==5)
               {
                  if(player[playernumber].Regbusi[m][5]==66 || player[playernumber].Regbusi[m][5]==98)
                    {
                 cout << "  구매\n";
         
                    }
              else
                        {
                     cout << "  매각\n";
      
                    }
               }
               else
                  cout << "    " << player[playernumber].Regbusi[m][n] <<"    ";
            }

            cout << "\n";
         }
      }else{  // 모든 배열 출 력 
         for(int s=0;s<6;s++)
         {
            for(int t=0;t<6;t++)
            {
               if(t==1)
                  printf("%s  ",Com[player[playernumber].Regbusi[s][1]-1].ComName);
               else if(t==5)
               {
                  if(player[playernumber].Regbusi[s][5]==66 || player[playernumber].Regbusi[s][5]==98)
                     cout << "  구매\n";
                  else
                     cout << "  매각\n";
               }
               else
                  cout << "    " << player[playernumber].Regbusi[s][t] <<"    ";
            }
            cout << "\n";
         }
      }     
   }else
      cout << "\n\n\t\t 아직 거래내역이 없습니다.\n\n\t\t";
   system("pause");
}


void User ::NowMyStock(int playernumber)   // 현재 유저가 가지고 있는 코인 
{
   system("cls");
   cout << " **************코인관리 시스템******************\n\n";
   printf("1. %s님 현재보유코인보기\n",player[playernumber].UserID);
   cout << " 거래소명  보유수량  전날코인금액  현재코인금액  현재손익(전날대비)  현 보유자산   카운트  \n\n\n";
   if(transcnt)
   {
      for(int i =0;i<4;i++)
      {
        if(Com[i].ComNum ==1){
            printf("%s  ",Com[i].ComName);    
        }
       else if(Com[i].ComNum ==2)
      {
            printf("%s  ",Com[i].ComName);
      }
         else if(Com[i].ComNum ==3)
        {
            printf("%s  ",Com[i].ComName);
        }
         else
       {   
            printf("%s  ",Com[i].ComName);
        }
         if(player[playernumber].Howbuy[i]==0)  // 사용자가 보유하고 있는 코인이 없을 경우 
            cout << "\t거래소에 대해서 보유하고 있는 코인이 없습니다.\n\n";
         else
         { 
            printf(" %3d %10d %15d",player[playernumber].Howbuy[i], Com[i].beforeStPri, Com[i].StPri);
            printf(" %15d %17d \t %3d \n\n", (Com[i].StPri - Com[i].beforeStPri)*player[playernumber].Howbuy[i], player[playernumber].Nowass, player[playernumber].Howbuy[i]);// 하우바이가 카운트에 해당 
            //마지막 변수 가지고 코인 가격 변경하기 
         }
      }
   } else {  
      cout << "\n\n\t\t거래내역이 없습니다.\n\n\t\t";
	}
   system("pause");
}

